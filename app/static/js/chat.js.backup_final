// AI Chat Widget JavaScript
// Handles SSE connection and chat interactions

class AIBookChat {
    constructor() {
        this.sessionId = this.getSessionId();
        this.eventSource = null;
        this.isConnected = false;
        
        // Anti-duplicate mechanisms
        this.messageVersions = new Map(); // Track message versions
        this.lastProcessedTime = new Map(); // Track last process time per message
        this.messageContentHash = new Map(); // Track content hashes
        
        this.initializeElements();
        this.setupEventListeners();
        
        // Auto-connect when widget is opened
        const widget = document.getElementById('chat-widget');
        if (widget && !widget.classList.contains('hidden')) {
            this.connectToSSE();
        }
    }

    getSessionId() {
        // Get or create session ID
        let sessionId = localStorage.getItem('chat_session_id');
        if (!sessionId) {
            sessionId = 'chat_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            localStorage.setItem('chat_session_id', sessionId);
        }
        return sessionId;
    }

    initializeElements() {
        this.chatWidget = document.getElementById('chat-widget');
        this.chatMessages = document.getElementById('chat-messages');
        this.chatInput = document.getElementById('chat-input');
        this.sendButton = document.getElementById('send-button');
        this.toggleButton = document.getElementById('chat-toggle');
        this.clearButton = document.getElementById('clear-chat');
        this.connectionStatus = document.getElementById('connection-status');
        
        // Also check for navbar AI Chat button
        this.navbarChatButton = document.querySelector('a[href="#"][onclick*="chat"]');
    }

    setupEventListeners() {
        // Toggle chat widget from floating button
        if (this.toggleButton) {
            this.toggleButton.addEventListener('click', (e) => {
                e.preventDefault();
                this.toggleChat();
            });
        }

        // Handle navbar AI Chat button
        if (this.navbarChatButton) {
            this.navbarChatButton.onclick = (e) => {
                e.preventDefault();
                this.toggleChat();
                return false;
            };
        }

        // Send message
        if (this.sendButton) {
            this.sendButton.addEventListener('click', () => this.sendMessage());
        }
        
        if (this.chatInput) {
            this.chatInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    this.sendMessage();
                }
            });
        }

        // Clear chat
        if (this.clearButton) {
            this.clearButton.addEventListener('click', (e) => {
                e.preventDefault();
                this.clearChat();
            });
        }
    }

    toggleChat() {
        if (this.chatWidget) {
            this.chatWidget.classList.toggle('hidden');
            
            // Connect to SSE when opening chat
            if (!this.chatWidget.classList.contains('hidden') && !this.isConnected) {
                this.connectToSSE();
            }
            
            // Focus input when opening
            if (!this.chatWidget.classList.contains('hidden') && this.chatInput) {
                this.chatInput.focus();
            }
        }
    }

    connectToSSE() {
        if (this.eventSource) {
            this.eventSource.close();
        }

        console.log('Connecting to chat stream...');

        // Connect to SSE endpoint
        this.eventSource = new EventSource(`/api/chat/stream/${this.sessionId}`);

        this.eventSource.onopen = () => {
            this.isConnected = true;
            this.updateConnectionStatus('connected');
            console.log('Connected to chat stream');
        };

        this.eventSource.onmessage = (event) => {
            try {
                const data = JSON.parse(event.data);
                this.handleMessage(data);
            } catch (e) {
                console.error('Error parsing message:', e);
            }
        };

        this.eventSource.onerror = (error) => {
            console.error('SSE error:', error);
            this.updateConnectionStatus('error');
            this.isConnected = false;
            
            // Reconnect after 5 seconds
            setTimeout(() => {
                if (!this.isConnected && this.chatWidget && !this.chatWidget.classList.contains('hidden')) {
                    this.connectToSSE();
                }
            }, 5000);
        };
    }

    // Simple hash function for content
    hashContent(content) {
        let hash = 0;
        for (let i = 0; i < content.length; i++) {
            const char = content.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash; // Convert to 32bit integer
        }
        return hash.toString();
    }

    handleMessage(data) {
        if (data.type === 'connected') {
            console.log('Chat connected successfully');
            return;
        }

        // DUPLICATE PREVENTION LOGIC
        const now = Date.now();
        const messageId = data.id;
        const currentVersion = data.version || 1;
        
        // Check 1: Version tracking
        const lastVersion = this.messageVersions.get(messageId) || 0;
        if (currentVersion <= lastVersion) {
            console.log(`üö´ Skipping old version: ${messageId} v${currentVersion} (have v${lastVersion})`);
            return;
        }
        
        // Check 2: Time window (prevent same content within 500ms)
        if (data.status === 'complete' && data.content) {
            const contentHash = this.hashContent(data.content);
            const lastTime = this.lastProcessedTime.get(contentHash) || 0;
            
            if (now - lastTime < 500) {
                console.log(`üö´ Skipping duplicate content within time window: ${messageId}`);
                return;
            }
            
            this.lastProcessedTime.set(contentHash, now);
        }
        
        // Update version tracking
        this.messageVersions.set(messageId, currentVersion);
        
        // Check if message already exists (by ID)
        const existingMsg = document.querySelector(`[data-message-id="${messageId}"]`);
        
        if (existingMsg) {
            // Update existing message (for status changes)
            const contentEl = existingMsg.querySelector('.message-content');
            if (contentEl) {
                if (data.status === 'thinking') {
                    contentEl.innerHTML = '<span class="thinking-dots"></span>';
                } else {
                    contentEl.innerHTML = this.parseMarkdown(data.content);
                    existingMsg.classList.remove('thinking');
                    
                    // Add fade-in effect for content update
                    existingMsg.classList.add('message-updated');
                    setTimeout(() => existingMsg.classList.remove('message-updated'), 300);
                }
            }
            
            console.log(`‚úÖ Updated message: ${messageId} to status: ${data.status}`);
        } else {
            // Add new message
            this.addMessageToChat(data);
            console.log(`‚úÖ Added new message: ${messageId} with status: ${data.status}`);
        }

        // Handle actions if present
        if (data.actions) {
            this.handleActions(data.actions);
        }
    }

    addMessageToChat(message) {
        const messageDiv = document.createElement('div');
        messageDiv.className = `message ${message.role} ${message.status === 'thinking' ? 'thinking' : ''} fade-in`;
        messageDiv.setAttribute('data-message-id', message.id);

        const avatar = document.createElement('div');
        avatar.className = 'avatar';
        avatar.textContent = message.role === 'user' ? 'üë§' : 'ü§ñ';

        const content = document.createElement('div');
        content.className = 'message-content';
        
        if (message.status === 'thinking') {
            content.innerHTML = '<span class="thinking-dots"></span>';
        } else {
            // Parse markdown-style bold text
            content.innerHTML = this.parseMarkdown(message.content);
        }

        // Add timestamp - FIXED format
        const timestamp = document.createElement('div');
        timestamp.className = 'message-timestamp';
        const time = new Date(message.timestamp || Date.now());
        timestamp.textContent = time.toLocaleTimeString([], { 
            hour: '2-digit', 
            minute: '2-digit',
            hour12: false  // Use 24-hour format
        });

        messageDiv.appendChild(avatar);
        messageDiv.appendChild(content);
        messageDiv.appendChild(timestamp);
        
        this.chatMessages.appendChild(messageDiv);
        this.scrollToBottom();
    }

    parseMarkdown(text) {
        // Enhanced markdown parsing
        return text
            .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
            .replace(/\*(.*?)\*/g, '<em>$1</em>')
            .replace(/\n/g, '<br>')
            .replace(/`(.*?)`/g, '<code>$1</code>');
    }

    handleActions(actions) {
        if (actions.type === 'book_results') {
            // Add book cards to chat
            const bookCardsDiv = document.createElement('div');
            bookCardsDiv.className = 'book-results fade-in';
            
            actions.books.forEach(book => {
                const bookCard = document.createElement('div');
                bookCard.className = 'mini-book-card';
                bookCard.innerHTML = `
                    <div class="book-card-header">
                        <h4>${book.title}</h4>
                        <span class="book-id">#${book.id}</span>
                    </div>
                    <p class="book-author">by ${book.author}</p>
                    <div class="book-actions">
                        <a href="/book/${book.id}" class="btn-view">View Details</a>
                        <button onclick="window.aiBookChat.saveBook(${book.id})" class="btn-save">üíæ Save</button>
                    </div>
                `;
                bookCardsDiv.appendChild(bookCard);
            });
            
            this.chatMessages.appendChild(bookCardsDiv);
            this.scrollToBottom();
        } else if (actions.type === 'save_book') {
            // Handle save book action
            this.saveBook(actions.book_id);
        }
    }

    async sendMessage() {
        const message = this.chatInput.value.trim();
        if (!message) return;

        // Disable input while sending
        this.chatInput.disabled = true;
        this.sendButton.disabled = true;

        // Clear input
        this.chatInput.value = '';

        // Add user message immediately
        this.addMessageToChat({
            id: 'temp_' + Date.now(),
            role: 'user',
            content: message,
            timestamp: new Date().toISOString()
        });

        try {
            // Build URL with query parameters
            const params = new URLSearchParams({
                message: message,
                session_id: this.sessionId
            });

            const response = await fetch(`/api/chat/send?${params}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                }
            });

            if (!response.ok) {
                const errorText = await response.text();
                console.error('Chat send error:', errorText);
                throw new Error('Failed to send message');
            }

            const data = await response.json();
            console.log('Message sent successfully:', data);

        } catch (error) {
            console.error('Error sending message:', error);
            // Remove the temporary user message
            const tempMsg = document.querySelector('[data-message-id^="temp_"]');
            if (tempMsg) tempMsg.remove();
            
            this.addMessageToChat({
                id: 'error_' + Date.now(),
                role: 'assistant',
                content: 'Sorry, I encountered an error sending your message. Please try again.',
                status: 'error'
            });
        } finally {
            // Re-enable input
            this.chatInput.disabled = false;
            this.sendButton.disabled = false;
            this.chatInput.focus();
        }
    }

    async saveBook(bookId) {
        try {
            const response = await fetch(`/api/books/${bookId}/save`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                }
            });

            if (response.ok) {
                // Show success message
                this.showNotification(`Book #${bookId} saved to your list!`, 'success');
                
                // Update button state
                const saveBtn = document.querySelector(`button[onclick*="saveBook(${bookId})"]`);
                if (saveBtn) {
                    saveBtn.textContent = '‚úÖ Saved';
                    saveBtn.disabled = true;
                }
            }
        } catch (error) {
            console.error('Error saving book:', error);
            this.showNotification('Failed to save book', 'error');
        }
    }

    async clearChat() {
        if (confirm('Are you sure you want to clear the chat history?')) {
            try {
                const response = await fetch(`/api/chat/clear/${this.sessionId}`, {
                    method: 'DELETE'
                });
                
                if (response.ok) {
                    // Clear messages except welcome
                    this.chatMessages.innerHTML = '';
                    
                    // Reset tracking maps
                    this.messageVersions.clear();
                    this.lastProcessedTime.clear();
                    this.messageContentHash.clear();
                    
                    this.addWelcomeMessage();
                }
            } catch (error) {
                console.error('Error clearing chat:', error);
                this.showNotification('Failed to clear chat', 'error');
            }
        }
    }

    addWelcomeMessage() {
        this.addMessageToChat({
            id: 'welcome',
            role: 'assistant',
            content: 'Hello! I\'m your AI Book Assistant. How can I help you find your next great read?\n\nYou can:\n‚Ä¢ Search for books\n‚Ä¢ Get recommendations\n‚Ä¢ Save books to your reading list',
            timestamp: new Date().toISOString()
        });
    }

    scrollToBottom() {
        if (this.chatMessages) {
            // Smooth scroll to bottom
            this.chatMessages.scrollTo({
                top: this.chatMessages.scrollHeight,
                behavior: 'smooth'
            });
        }
    }

    updateConnectionStatus(status) {
        if (this.connectionStatus) {
            this.connectionStatus.className = `connection-status ${status}`;
            this.connectionStatus.textContent = status === 'connected' ? 'üü¢ Connected' : 'üî¥ Disconnected';
            this.connectionStatus.title = status === 'connected' ? 'Connected to AI Assistant' : 'Connection lost, retrying...';
        }
    }

    showNotification(message, type) {
        const notification = document.createElement('div');
        notification.className = `notification ${type} show`;
        notification.textContent = message;
        document.body.appendChild(notification);
        
        setTimeout(() => {
            notification.classList.remove('show');
            setTimeout(() => notification.remove(), 300);
        }, 3000);
    }
}

// Initialize chat when DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
    // Prevent duplicate initialization
    if (!window.aiBookChat) {
        console.log('üöÄ Initializing AI Book Chat...');
        window.aiBookChat = new AIBookChat();
    } else {
        console.log('‚ÑπÔ∏è AI Book Chat already initialized');
    }
});
